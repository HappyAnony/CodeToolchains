控制流程语句
=================

和其它编程语言一样，shell的控制流程语句大体上也分为三种

- \ `顺序执行语句 <#orderstate>`_\ 
- \ `条件执行语句 <#conditionstate>`_\ 

	- \ `if条件语句 <#ifconditon>`_\ 
	- \ `case条件语句 <#casecondition>`_\ 
	- \ `select条件语句 <#selectcondition>`_\ 
	- \ `条件测试表达式 <#conteststate>`_\ 

		- \ `整数测试表达式 <#intergtest>`_\ 
		- \ `字符测试表达式 <#chartest>`_\ 
		- \ `文件测试表达式 <#filetest>`_\ 
- \ `循环执行语句 <#loopstate>`_\ 
	- \ `for循环语句 <#forloop>`_\ 
	- \ `while循环语句 <#whileloop>`_\ 
	- \ `until循环语句 <#untilloop>`_\ 

.. _orderstate:

0x00 顺序执行语句
~~~~~~~~~~~~~~~~~~~~

顺序执行语句是默认法则，即按照自上而下、自左往右的顺序逐条执行各命令，每执行一次就会得到对应的结果，然后退出该次执行操作

.. _conditionstate:

0x01 条件执行语句
~~~~~~~~~~~~~~~~~~~~

条件执行语句会根据判断条件选择符合条件的分支执行对应的\ ``cmd_list``\ 命令列表，执行完命令后就会退出该分支；条件执行语句有以下几种

- \ `if条件语句 <#ifconditon>`_\ 
- \ `case条件语句 <#casecondition>`_\ 
- \ `select条件语句 <#selectcondition>`_\ 

.. _ifconditon:

0x0100 if条件语句
^^^^^^^^^^^^^^^^^^

if条件语句的语法结构如下(使用\ ``help if``\ 命令可以查看)

.. code-block:: sh

	if TEST_COMMANDS; then
		COMMANDS_LIST;
	[elif TEST_COMMANDS; then
		COMMANDS_LIST;]
	...
	[else
		COMMANDS_LIST;]
	fi

其执行逻辑是

- \ **1.**\  先执行\ ``if``\ 分支下的\ ``TEST_COMMANDS``\ 条件测试命令，如果执行完的状态返回值为\ ``非0``\ ，则执行第2步；如果执行完的状态返回值为\ ``0``\ ，即\ ``TEST_COMMANDS``\ 条件测试命令执行成功，则执行该分支下的\ ``COMMANDS_LIST``\ 命令列表，执行完后就直接退出，此时整个if语句结构体的状态返回值取决于\ ``COMMANDS_LIST``\ 命令列表中最后一个命令的状态返回值
- \ **2.**\ 如果存在\ ``elif``\ 分支，则按照第一步的流程依次执行\ ``elif``\ 分支下的\ ``TEST_COMMANDS``\ 条件测试命令，如果没有一个\ ``elif``\ 分支的状态返回值为\ ``0``\ ，则执行第3步；如果存在一个\ ``elif``\ 分支的状态返回值为\ ``0``\ ，即该分支下的\ ``TEST_COMMANDS``\ 条件测试命令执行成功，则执行该分支下的\ ``COMMANDS_LIST``\ 命令列表，执行完后就直接退出，此时整个if语句结构体的状态返回值取决于\ ``COMMANDS_LIST``\ 命令列表中最后一个命令的状态返回值
- \ **3.**\ 如果\ ``else``\ 分支不存在，那么整个if语句结构体的状态返回值为\ ``0``\ ；如果存在\ ``else``\ 分支，则执行该分支下的\ ``COMMANDS_LIST``\ 命令列表，执行完后就直接退出，此时整个if语句结构体的状态返回值取决于\ ``COMMANDS_LIST``\ 命令列表中最后一个命令的状态返回值

在整个if语句结构体中有两个地方需要注意

- \ ``COMMANDS_LIST``\ ：表示待执行的命令列表，即一系列shell命令的集合，类型格式多种多样，在一系列示例代码中可见一斑

	- 注意：在命令列表中不能使用\ ``()``\ 操作符改变优先级，它的作用是让括号内的语句成为命令列表进入子shell中执行，它的具体作用可参考：\ `括号操作符 <../4-operator/index.html#parenthesel>`_\ 
- \ ``TEST_COMMANDS``\ ：表示条件测试命令，即通过引用条件测试命令的执行状态返回值是否为\ ``0``\ 来判断是否执行上述\ ``COMMANDS_LIST``\ 命令列表；\ **这里需要特别注意的是，和其它语言不通，shell的条件测试命令只有以下三种类型**\ 

	- \ ``命令执行``\ ：命令本身执行后就会产生对应的执行状态返回值，所以可以直接用来做条件判断

		- 此时不能使用\ **``**\ 操作符来引用命令，因为该操作引用的是命令的执行结果，而不是命令的执行状态返回值
		- 通常是直接使用命令，然后在命令后面添加\ ``s&> /dev/null``\ ，表示将命令的执行结果重定向至\ ``/dev/null``\ ，只引用其状态返回值；例如：\ ``if grep "^root" /etc/passwd &> /dev/null; then``\ 
	- \ ``执行条件测试表达式``\ ：在shell中，条件测试表达式是由条件测试操作符以及对应的操作数组成，详细介绍可参考下列：\ `条件测试表达式 <#conteststate>`_\ ，执行条件测试表达式有以下三种格式

		- \ ``test Test_Expression``\ ：通过\ ``test``\ 命令执行
		- \ ``[ Test_Expression ]``\ ：通过\ ``[]``\ 操作符执行，注意\ ``Test_Expression`` 前后有空格
		- \ ``[[ Test_Expression ]]``\ ：通过\ ``[[]]``\ 操作符执行，注意\ ``Test_Expression`` 前后有空格
	- \ ``组合条件测试``\ ：即对多个\ ``命令执行状态返回值``\ 或者\ ``执行条件测试表达式状态返回值``\ 做逻辑运算，组合条件测试有以下三种格式

		- 逻辑与操作：只有当\ ``&&``\ 操作符两边执行结果都为真(状态值为0)，最后组合条件测试结果才为真(状态值为0)

			- \ ``[ Test_Expression1 ] && [ Test_Expression2 ]``\ ：此处使用\ ``[]``\ 或\ ``[[]]``\ 都行
			- \ ``COMMAND &> /dev/null && [ Test_Expression2 ]``\ ：此处使用\ ``[]``\ 或\ ``[[]]``\ 都行
			- \ ``COMMAND1 &> /dev/null && COMMAND2 &> /dev/null &&``\ 
			- \ ``[ Test_Expression1 -a Test_Expression2 ]``\ ：此处使用\ ``[]``\ 或\ ``[[]]``\ 都行
			- \ ``[[ Test_Expression1 && Test_Expression2 ]]``\ ：此处只能使用\ ``[[]]``\ 操作符，因为\ ``&&``\ 运算符不允许用于\ ``[]``\ 操作符中
		- 逻辑或操作：只要\ ``||``\ 操作符两边执行结果有一个为真(状态值为0)，最后组合条件测试结果就为真(状态值为0)

			- \ ``[ Test_Expression1 ] || [ Test_Expression2 ]``\ ：此处使用\ ``[]``\ 或\ ``[[]]``\ 都行
			- \ ``COMMAND &> /dev/null || [ Test_Expression2 ]``\ ：此处使用\ ``[]``\ 或\ ``[[]]``\ 都行
			- \ ``COMMAND1 &> /dev/null || COMMAND2 &> /dev/null &&``\ 
			- \ ``[ Test_Expression1 -0 Test_Expression2 ]``\ ：此处使用\ ``[]``\ 或\ ``[[]]``\ 都行
			- \ ``[[ Test_Expression1 || Test_Expression2 ]]``\ ：此处只能使用\ ``[[]]``\ 操作符，因为\ ``||``\ 运算符不允许用于\ ``[]``\ 操作符中
		- 逻辑非操作：对\ ``!``\ 右侧执行结果取反

			- \ ``! [ Test_Expression ]``\ ：此处使用\ ``[]``\ 或\ ``[[]]``\ 都行
			- \ ``! COMMAND1 &> /dev/null``\ 
			- \ ``! ([ Test_Expression1 ] || [ Test_Expression2 ])``\ ：此处相当于\ ``! [ Test_Expression1 ] && ! [ Test_Expression2 ]``\ 
			- \ ``! ([ Test_Expression1 ] && [ Test_Expression2 ])``\ ：此处相当于\ ``! [ Test_Expression1 ] || ! [ Test_Expression2 ]``\ 
		- 注意：\ **非的优先级大于与，与的优先级大于或**\ 

示例代码如下

- 输出两个传入参数中的最大值

.. code-block:: sh

	#!/bin/bash
	if [ $# -lt 2 ]; then
	        echo "`basename $0` arg1 arg2"
	        exit 1
	fi
	if [ $1 -gt $2 ]; then
	        echo "the max num is $1"
	else
	        echo "the max num is $2"
	fi

- 计算1~200之间偶数之和

.. code-block:: sh

	#!/bin/bash

	declare -i sum=0
	for i in {1..200};do
	        if [ $[$i%2] -eq 0 ]; then
	                let sum+=$i
	        fi
	done

	echo "the sum is : $sum"


- 让用户输入一个用户名，先判断该用户是否存在，不存在，则以7为退出码；如果存在，判断用户的shell是否为\ ``/bin/bash``\ ，如果是，则显示为\ ``Bash User``\ ，退出码为0，否则显示为\ ``Not Bash User``\ ，退出码为1

.. code-block:: sh


	#!/bin/bash

	read -p "please input username: " username

	echo $username
	if ! grep "^$username\>" /etc/passwd &> /dev/null; then
	        echo "User not exist"
	        exit 7
	elif [[ `grep "^$username\>" /etc/passwd | cut -d: -f7` =~ /bin/bash ]];then
	        echo "Bash User"
	        exit 0
	else
	        echo "Not Bash User"
	        exit 1
	fi

- 统计输入文件的空白行数

.. code-block:: sh

	#!/bin/bash

	read -p "Enter a file path: " filename

	if grep "^$" $filename &> /dev/dull; then
	        linesCount=`grep "^$" $filename | wc -l`
	        echo "$filename has $linesCount space lines"
	else
	        echo "$filename has no space linse"
	fi

.. _casecondition:

0x0101 case条件语句
^^^^^^^^^^^^^^^^^^^^^^

case条件语句的语法结构如下(使用\ ``help case``\ 命令可以查看)

.. code-block:: sh

	case WORD in 
		PATTERN1) 
			COMMANDS_LIST
			;;
		PATTERN2)
			COMMANDS_LIST
			;;
		PATTERN3)
			COMMANDS_LIST
			;;
		... 
	esac

其执行逻辑是：\ ``WORD``\ 依次匹配\ ``PATTERN1``\ 、\ ``PATTERN2``\ 、\ ``PATTERN3``\ ......；如果所有模式都没有匹配上，则直接退出\ ``case``\ 语句，此时执行状态返回值为\ ``0``\ ；如果匹配上任意一个\ ``PATTERN``\ 就执行该分支下面的\ ``COMMANDS_LIST``\ 命令列表，执行完后就直接退出，此时整个case语句结构体的状态返回值取决于\ ``COMMANDS_LIST``\ 命令列表中最后一个命令的状态返回值；模式的匹配优先级是\ ``PATTERN1``\ > \ ``PATTERN2``\ > \ ``PATTERN3``\ > \ ``......``\ 

在以上结构中，有以下几点需要注意

- case中的每个小分支都以双分号\ ``;;``\ 结尾，表示执行完该分支后直接退出\ ``case``\ 语句；但最后一个小分句的双分号可以省略。实际上，小分句除了使用\ ``;;``\ 结尾，还可以使用\ ``;&``\ 和\ ``;;&``\ 结尾，只不过意义不同，如下

	- \ ``;;``\ 符号表示小分支执行完成后立即退出case语句
	- \ ``;&``\ 符号表示继续执行下一个小分支中的\ ``COMMANDS_LIST``\ 部分，而无需进行匹配动作，并由此小分支的结尾符号来决定是否继续操作下一个小分句
	- \ ``;;&``\ 符号表示继续向后(不止是下一个，而是一直向后)匹配小分支，如果匹配成功，则执行对应小分支中的\ ``COMMANDS_LIST``\ 部分，并由此小分支的结尾符号来决定是否继续向后匹配
- 每个小分支中的\ ``PATTERN``\ 部分都使用括号\ ``()``\ 包围，只不过左括号\ ``(``\ 不是必须的
- 一般最后一个小分支使用的\ ``PATTERN``\ 是\ ``*``\ ，表示无法匹配前面所有小分支时，将匹配该小分支；用来避免case语句无法匹配的情况，在shell脚本中，此小分支一般用于提示用户脚本的使用方法，即给出脚本的\ ``Usage``\ 

这里也需要说明下以下两个关键组成成分

- \ ``WORD``\ ：一般是字符串类型
- \ ``PATTERN``\ ：该模式支持\ `通配符机制 <../../../../5-Wildcard/1-FileWildcard.html>`_\ (注意不是正则表达式)

	- \ ``*``\ ：匹配任意长度的任意字符
	- \ ``?``\ : 匹配单个任意字符
	- \ ``[]``\ : 匹配指定字符范围内的任意单个字符，不区分大小写

	    - \ ``[a-z]``\ ：不区分大小写，可以匹配大写字母
	    - \ ``[A-Z]``\ ：不区分大小写，可以匹配小写字母
	    - \ ``[0-9]``\ ：匹配0到9任意单个数字
	    - \ ``[a-z0-9]``\ ：匹配单个字母或数字
	    - \ ``[[:upper:]]``\ ：匹配单个大写字母
	    - \ ``[[:lower:]]``\ ：匹配单个小写字母
	    - \ ``[[:alpha:]]``\ ：匹配单个大写或小写字母
	    - \ ``[[:digit:]]``\ ：匹配单个数字
	    - \ ``[[:alnum:]]``\ ：匹配单个字母或数字
	    - \ ``[[:space:]]``\ ：匹配单个空格字符
	    - \ ``[[:punct:]]``\ ：匹配单个标点符号

	- \ ``[^]``\ : 匹配指定字符范围外的任意单个字符

	    - \ ``[^a-z]``\ ：匹配字母之外的单个字符
	    - \ ``[^A-Z]``\ ：匹配字母之外的单个字符
	    - \ ``[^0-9]``\ ：匹配数字之外的单个字符
	    - \ ``[^a-z0-9]``\ ：匹配字母和数字之外的单个字符
	    - \ ``[^[:upper:]]``\ ：匹配大写字母之外的单个字符
	    - \ ``[^[:lower:]]``\ ：匹配小写字母之外的单个字符
	    - \ ``[^[:alpha:]]``\ ：匹配字母之外的单个字符
	    - \ ``[^[:digit:]]``\ ：匹配数字之外的单个字符
	    - \ ``[^[:alnum:]]``\ ：匹配字母和数字之外的单个字符
	    - \ ``[^[:space:]]``\ ：匹配空格字符之外的单个字符
	    - \ ``[^[:punct:]]``\ ：匹配标点符号之外的单个字符
	- \ ``|``\ ：用来分隔上述\ ``*``\  、\ ``?``\ 、\ ``[]``\ 、\ ``[^]``\ 通配元字符；例如\ ``([yY] | [yY][eE][sS]])``\ 表示即可以输入单个字母的\ ``y或Y``\ ，还可以输入\ ``yes三个字母的任意大小写格式``\ 

示例代码如下

.. code-block:: sh

	#!/bin/bash
	set -- y

	case "$1" in
	    ([yY]|[yY][eE][sS])
	        echo yes;&
	    ([nN]|[nN][oO])
	        echo no;;
	    (*)
	        echo wrong;;
	esac

	# 执行结果如下
	# yes
	# no

其中\ ``set -- string_list``\ 的作用是将\ ``string_list``\ 按照\ ``IFS``\ 分隔后分别赋值给位置变量\ ``$1、$2、$3...``\ ，因此此处是为\ ``$1``\ 赋值字符\ ``y``\ 

在此示例中，\ ``$1``\ 能匹配第一个小分支，但第一个小分支的结尾符号为\ ``;&``\ ，所以无需判断地直接执行第二个小分支的\ ``echo no``\ ，但第二个小分支的结尾符号为\ ``;;``\ ，于是直接退出case语句。因此，即使\ ``$1``\ 无法匹配第二个小分句，case语句的结果中也输出了\ ``yes``\ 和\ ``no``\ 

.. code-block:: sh

	#!/bin/bash
	set -- y

	case "$1" in
	    ([yY]|[yY][eE][sS])
	        echo yes;;&
	    ([nN]|[nN][oO])
	        echo no;;
	    (*)
	        echo wrong;;
	esac

	# 执行结果如下
	# yes
	# wrong

在此示例中，\ ``$1``\ 能匹配第一个小分支，但第一个小分支的结尾符号为\ ``;;&``\ ，所以继续向下匹配，第二个小分支未匹配成功，直到第三个小分支才被匹配上，于是执行第三个小分支中的\ ``echo wrong``\ ，但第三个小分支的结尾符号为\ ``;;``\ ，于是直接退出case语句。所以，结果中输出了\ ``yes``\ 和\ ``wrong``\ 




.. _selectcondition:

0x0102 select条件语句
^^^^^^^^^^^^^^^^^^^^^^^

.. _loopstate:


.. _conteststate:

0x0103 条件测试表达式
^^^^^^^^^^^^^^^^^^^^^^^^^^^

条件测试表达式有以下几种类型

- \ `整数测试表达式 <#intergtest>`_\ 
- \ `字符测试表达式 <#chartest>`_\ 
- \ `文件测试表达式 <#filetest>`_\ 

.. _intergtest:

整数测试表达式的格式为：\ ``NUM1 操作符 NUM2``\ 

- \ ``NUM1``\ 和\ ``NUM2``\ 是整数，可以直接是整数值(例如：\ ``2``\ )，可以是变量引用(例如：\ ``$#``\ )，也可以是算术运算得到的值(参考\ `算术运算 <../2-datatype/index.html#arithmeticl>`_\ )
- 整数测试操作符有

	- \ ``-eq``\ ：等于
	- \ ``-ne``\ ：不等于
	- \ ``-le``\ ：小于等于
	- \ ``-ge``\ ：大于等于 
	- \ ``-lt``\ ：小于
	- \ ``-gt``\ :大于

.. _chartest:

字符测试表达式的格式有两种格式

- 双目测试格式：\ ``STR1 双目操作符 STR2``\ 
	
	- \ ``STR1``\ 和\ ``STR2``\ 是字符串，shell中默认数据类型是字符串，即不带\ ``""``\ 默认都会被当做字符串类型；但是在此处，必须使用\ ``""``\ (除非是模式匹配中的模式字符串，才不用引号)
	- 双目测试操作符有

		- \ ``>``\ ：表示左边的字符串大于右边的字符串
		- \ ``<``\ ：表示左边的字符串小于右边的字符串
		- \ ``==``\ ：表示左边的字符串等于右边的字符串
		- \ ``!=``\ 、\ ``<>``\ ：表示左右两边的字符串完全不相等
		- \ ``=~``\ ：左侧是普通字符串，右侧是一个模式字符串，用来判断左侧的字符串能否被右侧的模式所匹配：但是必须在\ ``[[]]``\ 中才能执行模式匹配；模式中可以使用行首、行尾锚定符，但是\ **模式不要加引号**\ ，有时候可能不需要转义，具体模式书写格式可参考\ `正则表达式 <../../../../5-Wildcard/2-Regular/1-syntax/index.html>`_\ 
- 单目测试格式：\ ``单目操作符 STR``\ 

	- \ ``STR``\ 是字符串，shell中默认数据类型是字符串，即不带\ ``""``\ 默认都会被当做字符串类型；但是在此处，必须使用\ ``""``\ 
	- 单目测试操作符有

		- \ ``-n``\ : 判断字符串是否不空，不空为真，空则为假
		- \ ``-z``\ ：判断字符串是否为空，空则为真，不空则假

.. _filetest:

文件测试表达式的格式也有两种

- 单目测试格式：\ ``单目操作符 FILE``\ 

	- \ ``FILE``\ 是文件名，一般使用绝对路径
	- 单目操作符有

		- \ ``-e FILE``\ ：测试文件是否存在
		- \ ``-a FILE``\ ：测试文件是否存在
		- \ ``-f FILE``\ ：测试是否为普通文件
		- \ ``-d FILE``\ ： 测试是否为目录文件
		- \ ``-b FILE``\ ：测试文件是否存在并且是否为一个块设备文件
		- \ ``-c FILE``\ ：测试文件是否存在并且是否为一个字符设备文件
		- \ ``-h|-L FILE``\ ：测试文件是否存在并且是否为符号链接文件
		- \ ``-p FILE``\ ：测试文件是否存在并且是否为管道文件：
		- \ ``-S FILE``\ ：测试文件是否存在并且是否为套接字文件：
		- \ ``-r FILE``\ ：测试其有效用户是否对此文件有读取权限
		- \ ``-w FILE``\ ：测试其有效用户是否对此文件有写权限
		- \ ``-x FILE``\ ：测试其有效用户是否对此文件有执行权限
		- \ ``-s FILE``\ ：测试文件是否存在并且不空
- 双目测试格式：\ ``FILE1 双目操作符 FILE2``\ 

	- \ ``FILE1``\ 和\ ``FILE2``\ 是文件名，一般使用绝对路径
	- 双目操作符有

		- \ ``FILE1 -nt FILE2``\ ：测试FILE1是否比FILE2更new一些
		- \ ``FILE1 -ot FILE2``\ ：测试FILE1是否比FILE2更old一些


0x02 循环执行语句
~~~~~~~~~~~~~~~~~~~

循环执行语句会根据判断条件循环多次执行对应的循环体\ ``cmd_list``\ 命令列表，当判断条件不满足时就会退出该循环体；循环执行语句有以下几种

- \ `for循环语句 <#forloop>`_\ 
- \ `while循环语句 <#whileloop>`_\ 
- \ `until循环语句 <#untilloop>`_\ 

.. _forloop:

0x0200 for循环语句
~~~~~~~~~~~~~~~~~~~~

.. _whileloop:

0x0201 while循环语句
~~~~~~~~~~~~~~~~~~~~~~~

.. _untilloop:

0x0202 until循环语句
~~~~~~~~~~~~~~~~~~~~~


