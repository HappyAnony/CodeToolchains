文本查找
=================

命令汇总

- \ `cut <#cutl>`_\ 
- \ `grep <#grepl>`_\ 
- \ `egrep <#egrepl>`_\ 
- \ `awk <#awkl>`_\ 
	- \ `awk选项 <#optionsl>`_\ 
	- \ `awk程序 <#programl>`_\ 
		- \ `awk匹配模式 <#patternl>`_\ 
		- \ `awk动作之变量 <#awkvarl>`_\ 
		- \ `awk动作之操作符 <#awkoperal>`_\ 
		- \ `awk动作之控制流 <#awkctrl>`_\ 
		- \ `awk动作之函数 <#awkfuncl>`_\ 
	- \ `awk应用 <#awkappl>`_\ 

这些工具可以称之为文本过滤器，它们会根据用户指定的文本模式对目标文件或目标字节流进行逐行搜索匹配，并输出匹配文本模式的整行信息或特定字段

.. _cutl:

0x01 cut
~~~~~~~~~~

\ ``cut``\ 命令会根据指定的分隔符对每行文本内容进行切片，并显示出每行需要的切片

命令常用选项有：

- \ ``-d``\ ：后面紧跟字符，将该字符指定为行分隔符；默认是以\ ``tab``\ 键为分隔符
- \ ``-f``\ ：后面紧跟数字，以字段为单位显示文本每行内容；一般和\ ``-d``\ 选项指定分隔符一起使用
- \ ``-b``\ ：后面紧跟数字，以字节为单位显示文本每行内容，不需要指定分隔符
- \ ``-c``\ ：后面紧跟数字，以字符为单位显示文本每行内容，不需要指定分隔符
- \ ``--complement``\ ：显示文本每行没有被\ ``-b``\ 、\ ``-c``\ 、\ ``-f``\ 选项匹配到的内容
- \ ``-s``\ ：不显示没有被\ ``-f``\ 选项匹配到的行，和\ ``-f``\ 选项一起使用

\ ``-b``\ 、\ ``-c``\ 、\ ``-f``\ 选项后面数字都支持以下形式： 

- 一个字段、字节或字符使用一个数字即可
- 多个离散字段、字节或字符使用\ ``,``\ 分隔多个数字
- 多个连续字段、字节或字符使用\ ``-``\ 连接两个数字

    - \ ``N-``\ 表示第N个字段、字节或字符到结尾
    - \ ``-M``\ 表示第1到第M个字段、字节或字符
    - \ ``N-M``\ 表示第N到第M个字段、字节或字符




.. code-block:: sh

	$cut -f2 1.txt               # 默认以tab为分隔符
	$cut -f2 -s 1.txt            # 如果没有第2字段，则不打印该行内容
	$cut -d: -f1 /etc/passwd     # 以:分隔/etc/passwd每行内容，打印每行分隔后的第一个字段
	$cut -c1-5 /etc/passwd       # 打印每行第1到第5个字符
	$cut -b-2 /etc/passwd        # 打印每行前2个字节内容
	$cut -c1 --complement 1.txt  # 打印每行除第1个字符之外的所有字符

.. _grepl:

0x01 grep
~~~~~~~~~~~~

参考文档

- \ `grep命令中文手册 <http://www.cnblogs.com/f-ck-need-u/p/7462706.html>`_\ 

man文档关于grep命令的介绍是：\ ``global search basic regular expression（RE）and print out the line``\ ，即基本正则表达式搜索，输出整行信息。它可接收文件或字节流作为搜索对象

\ ``grep``\ 命令使用的语法格式：\ ``grep [OPTIONS] PATTERN [FILE...]``\ 

- OPTIONS常用选项

	- \ ``--color[=WHEN]``\ ：将匹配到文本模式的信息以指定的颜色显示出来。默认auto值是红色
	- \ ``-v``\ ：反向匹配，显示不能被模式匹配到的行
	- \ ``-o``\ ：仅显示被模式匹配到的字串，而非整行
	- \ ``-c``\ ：统计文件中包含文本的次数
	- \ ``-n``\ ：打印文本匹配的行号
	- \ ``-I``\ ：只打印文件名
	- \ ``-r``\ ：多级目录中对文本递归搜索，不包括符号链接文件
	- \ ``-R``\ ：多级目录中对文本递归搜索，包括符号链接文件
	- \ ``-i``\ ：不区分大小写，ignore-case
	- \ ``-E``\ ：默认只支持基本正则表达式，如果想使用扩展正则表达式需要用-E选项
	- \ ``-A num``\ ：不仅显示匹配到的行，还显示模式下面的num行
	- \ ``-B num``\ ：不仅显示匹配到的行，还显示模式上面的num行
	- \ ``-C num``\ ：不仅显示匹配到的行，前后各显示num行
- PATTERN：查找匹配模式

	- \ `基本正则表达式BRE <../../../5-Wildcard/2-Regular/1-syntax/1-bRegEx.html>`_\ 使用\ ``-e``\ 选项，但是由于基本正则是默认支持的，所有可以省略
	- 如果想要支持\ `扩展正则表达式ERE <../../../5-Wildcard/2-Regular/1-syntax/2-eRegEx.html>`_\ ，则需要在PATTERN之前加上\ ``-E``\ 选项
	- 如果想要支持\ `Perl正则表达式PCRE <../../../5-Wildcard/2-Regular/2-engine/3-perl.html>`_\ ，则需要在PATTERN之前加上\ ``-P``\ 选项
- FILE：查找匹配对象

	- 可以是文件名
	- 也可以是管道送过来的字节流

\ **注意**\ ：\ ``PATTERN``\ 中一旦使用正则表达式的元字符(\ ``^``\ ,\ ``$``\ 等)作为文本模式，就需要用引号括起来：

- 单引号，表示强引用，不允许做变量替换
- 双引号，表示弱引用，允许做变量替换

.. code-block:: sh

	$grep -R -n "class" .               # 多级目录中对class文本进行递归搜索，打印所在文件，行号以及整行内容
	$grep -e "class" -e "vitural" file  # 匹配多个模式
	$grep -rnP "\xE4\xB8\xAD\xE6\x96\x87|\xD6\xD0\xCE\xC4" . # 使用perl正则在多级目录中递归搜索utf-8编码和gb2312编码分别是E4B8ADE69687和D6D0CEC4的中文
	$cat LOG.* | tr a-z A-Z | grep "FROM" | grep "WHERE" > b # 将日志中的所有带where条件的sql查找查找出来

.. _egrepl:

0x02 egrep
~~~~~~~~~~~~

\ ``egrep``\ 命令的使用方法和\ ``grep``\ 命令完全一样，唯一区别就是：\ ``egrep``\ 命令使用扩展正则表达式作为默认文本模式，相当于\ ``grep -E``\ 


.. _awkl:

0x03 awk
~~~~~~~~~~

参考文档

- \ `awk知识点全回顾 <http://www.cnblogs.com/f-ck-need-u/p/7509812.html#blog6>`_\

awk是一个报告生成工具(过滤显示工具)，它的工作机制是：使用指定的分隔符将读取的每一行数据进行切割，然后根据PATTERN文本模式匹配每一行内容，最后执行action动作处理匹配到的行内容

awk的分支有

- awk：早期使用
- nawk(new awk)：付费使用
- gawk(GNU awk)：linux平台使用，在linux上awk只是gawk的一个符号链接

.. figure:: ../images/1.png

\ ``awk``\ 命令的语法格式有两种：

- \ ``awk [OPTIONS] -f program-file [ -- ] FILE ...``\ 
- \ ``awk [OPTIONS] [ -- ] program FILE ...``\ 

两种语法大同小异，\ ``program-file``\ 只是文件内容为\ ``program``\ 的文件名而已。其中\ ``FILE``\ 是\ ``awk``\ 命令的操作对象，可以是以空格分隔的多个文件名，也可以是管道传送过来的字符流，至于\ ``OPTIONS``\ 和\ ``program``\ 需要详细说明下

.. _optionsl:

0x0300 OPTIONS
+++++++++++++++

常用选项有：

- \ ``-F``\ ：指定输入行的字段分隔符，也可以通过设置内置变量"FS"实现，默认字段分隔符为空白符，也可通过正则表达式指定分隔符

	- \ ``-F " "``\ ：默认的，会压缩所有前导空白，包括制表符和空格
	- \ ``-F " :"``\ ：当空格后跟一个冒号时作为分隔符。会压缩前导空格，但不会匹配制表符，更不会压缩制表符
	- \ ``-F "[ ]"``\ ：只表示一个空格，不压缩任何空白
	- \ ``-F "|"``\ ：指定竖线作为分隔符
	- \ ``-F ",[ \t]*|[ \t]+"``\ ：逗号后跟0或多个空白，或者只有1或多个空白时作为分隔符

.. _programl:

0x0301 program
++++++++++++++++

\ ``program``\ 是\ ``awk``\ 的重中之重，称为awk的程序，它的格式为：\ ``'BEGIN{ACTIONS}PATTERN{ACTIONS}END{ACTIONS}'``\ ，注意此处有单引号，由此得出awk详细的执行流程是：

- \ ``awk``\ 读取第一个文件第一行之前执行\ ``BEGIN``\ 后面的\ ``ACTIONS``\ 程序，该程序通常用于输出一个标题，或者初始化一些格式、变量等
- \ ``awk``\ 每读取文件的一行内容就使用\ ``BEGIN``\ 或\ ``OPTIONS``\ 中定义的输入字段分隔符和输入行分隔符对行内容进行段分隔和行分隔，然后将该行内容与\ ``PATTERN``\ 文本模式进行匹配比较，如果行内容能够匹配上则执行\ ``PATTERN``\ 后面的\ ``ACTIONS``\ 程序
- \ ``awk``\ 处理完最后一个文件的最后一行后执行\ ``END``\ 后面的\ ``ACTIONS``\ 程序，该程序通常用于最后的总结性输出

在\ ``program``\ 中\ 

- ``BEGIN{ACTIONS}``\ 字段不用提供输入流，\ ``BEGIN``\ 是固定字样，类似于类中的构造函数入口，\ ``ACTIONS``\ 是构造函数的函数体，其语法和\ ``PATTERN``\ 对应的\ ``ACTIONS``\ 语法一致，功能主要是初始化
- ``PATTERN{ACTIONS}``\ 是核心字段，称之为\ ``主输入循环(main input loop)``\ ，在进入主输入循环之前，可以不用提供输入流，但进入主输入循环后，必须提供输入流。

	- \ ``PATTERN``\ 称之为文本模式，类似于类中特定函数方法的调用入口，只有满足该文本模式的内容，才能调用其对应的执行函数体
	- \ ``ACTIONS``\ 称之为执行动作，类似于上述函数方法的函数体，只有满足前面的文本模式的内容，才能调用该函数体
	- 其中\ ``PATTERN``\ 或\ ``ACTIONS``\ 二者可省一：省略\ ``PATTERN``\ 时表示对所有输入流都执行\ ``ACTIONS``\ ，省略\ ``ACTIONS``\ 表示对符合条件的输入流都执行默认的\ ``print动作``\ 
- \ ``END{ACTIONS}``\ 字段不用提供输入流，\ ``END``\ 是固定字样，类似于类中的析构函数入口，\ ``ACTIONS``\ 是析构函数的函数体，其语法和\ ``PATTERN``\ 对应的\ ``ACTIONS``\ 语法一致，功能主要是收尾处理

由上述可知，我们需要关注的只有\ ``PATTERN``\ 文本模式以及\ ``BEGIN/PATTERN/END``\ 对应的\ ``ACTIONS``\ 执行动作

.. _patternl:

\ ``PATTERN``\ ：文本模式，用来过滤输入流，只有匹配文本模式的输入流才能执行\ ``PATTERN``\ 对应的\ ``ACTIONS``\ 工作，文本模式的形式有以下几种：

- \ ``/regexp/``\ ：正则匹配模式，\ ``regexp``\ 为正则表达式，需要使用\ ``//``\ 将其括起来，有两种匹配表达式：

	- \ ``/regexp/``\ ：表示当前行内容能被\ ``regexp``\ 匹配则为真
	- \ ``!/regexp/``\ ：表示当前行内容不能被\ ``regexp``\ 匹配就为真
	- 例如：\ ``awk -F : '/^root\>/{print $1,$7}' /etc/passwd``\ 打印/etc/passwd文件中以root开头的行
- \ ``expression``\ ：表达式匹配模式，\ ``expression``\ 是由操作符合左右数组合而成，\ ``expression``\ 不需要加斜线，且\ ``expression``\ 中操作符、左右数之间没有空格

	- 支持的操作符有：

		- 比较操作符有：

			- 数值比较：\ ``<、<=、==、!=、>=、>``\ 
			- 正则匹配：\ ``~``\ 表示能被右数\ ``/regexp/``\ 匹配模式匹配，如\ ``$7~/bash$/``\ 
			- 正则反匹配：\ ``!~``\ 表示不能被右数\ ``/regexp/``\ 匹配模式匹配，如\ ``$7!~/bash$/``\ 
		- 算术操作符有：\ ``+、-、*、/、%、^(取幂)、**(取幂，非POSIX标准，不可移植)``\  
		- 逻辑操作符有：\ ``&&、||、!``\ ，如\ ``$4 == "Asia" && $3 > 500``\ ，\ ``! (NR > 1 && NF > 3)``\ 
	- 操作符左数可以是

		- 使用\ `位置参数 <#siteargl>`_\ ：\ ``$0``\ 表示整行、\ ``$1~$n``\ 分别表示被输入字段分隔符分隔号的\ ``第1字段``\ 和\ ``第n字段``\ 
		- 使用\ `内置变量 <#builtinl>`_\ 
	- 操作符右数可以是

		- 如果左数是数值，则操作符一般是数值比较，右数一般也是数值
		- 如果左数是字符串，则操作符一般是正则匹配，右数一般是\ ``/regexp/``\ 
	- 例如：\ ``awk -F : '$7~/bash$/{print $1}' /etc/passwd``\ 打印/etc/passwd文件中第7段是以bash结尾的行的第1段
- 地址定界模式，该模式有两种形式

	- \ ``/regexp1/,/regexp2/``\ ：第一次被\ ``regexp1``\ 匹配到的行开始到第一次被\ ``regexp2``\ 匹配到的行结束，这些内容都可以执行\ ``PATTERN``\ 后面的\ ``ACTIONS``\ 动作
	- \ ``expression1,expression2``\ ：第一次满足\ ``expression1``\ 的行开始到第一次满足\ ``expression2``\ 的行结束，这些内容都可以执行\ ``PATTERN``\ 后面的\ ``ACTIONS``\ 动作

需要注意的是：\ ``regexp``\ 正则表达式可以被赋值给一个变量，然后引用该变量来匹配数据

.. code-block:: sh

	reg="^[0-9]+$"
	$2~reg

.. _awkvarl: 

\ ``awk``\ 中支持的变量有以下几类

- 普通变量：也可以称为自定义变量

	- 如果要赋值字符串给自定义变量，则应该使用双引号将其括起来：\ ``reg="^[0-9]+$"``\ 
	- 如果要赋值数值给自定义变量，则不需要使用双引号：\ ``reg=9``\ 
- 字段变量：每行内容被输入字段分隔符分隔形成的变量

	- \ ``$0``\ ：表示整行内容
	- \ ``$1~$n``\ ：表示每行使用分隔符分隔后的第一字段~第n字典
- 内置变量：该变量可分为两类

	- awk内部自动修改的变量

		- \ ``ARGV``\ ：命令行参数数组，从0开始计数直到ARGC-1
		- \ ``ARGC``\ ：ARGV数组元素的个数
		- \ ``FILENAME``\ ：当前处理的文件名
		- \ ``FNR``\ ：当前处理文件的记录号(行号)(file record num)
		- \ ``NR``\ ：已处理的总记录数(总行数)，多个文件时不重置(record num)
		- \ ``NF``\ ：当前行使用分隔符分隔完后的字段总数(field num) 
	- awk内部不会改动的系统变量，完全需要手动修改，这类一般都有默认值

		- \ ``FS``\ ：输入字段分隔符，默认为空白(field separate)
		- \ ``OFS``\ ：输出字段分隔符，默认为空白(output field separate)
		- \ ``RS``\ ：输入流记录(行)分隔符，默认为\ ``\n``\ ，该变量只取变量值的第一个字符(record separate)
		- \ ``ORS``\ ：输出流记录(行)分隔符，默认为\ ``\n``\ ，该变量只取变量值的第一个字符(output record separate)
		- \ ``OFMT``\ ：printf输出数值转换成字符串输出时的格式，默认为\ ``%.6g``\ 
		- \ ``CONVFMT``\ ：printf输出数值转换成字符串输出时的格式，会被OFMT覆盖，默认为\ ``%.6g``\ 
		- \ ``RLENGTH``\ ：被match函数匹配的字符串的长度
		- \ ``RSTART``\ ：被match函数匹配的字符串的开始位置
		- \ ``SUBSEP``\ ：下标分隔符，默认为\ ``\034``\ ，ASCII中\ ``034``\ 代表的是双引号\ ``"``\ 

.. _awkoperal:

\ ``awk``\ 支持的运算符有

- 比较操作符：

	- 数值比较：\ ``<、<=、==、!=、>=、>``\ 
	- 正则匹配：\ ``~``\ 表示能被右数\ ``/regexp/``\ 匹配模式匹配，如\ ``$7~/bash$/``\ 
	- 正则反匹配：\ ``!~``\ 表示不能被右数\ ``/regexp/``\ 匹配模式匹配，如\ ``$7!~/bash$/``\ 
- 算术操作符：\ ``+、-、*、/、%、^(取幂)、**(取幂，非POSIX标准，不可移植)``\  
- 赋值操作符：\ ``++、--、+=、-=、*=、/=、%=、^=、**=``\ awk支持复合赋值，例如\ ``FS = OFS = "\t"``\ 表示输入字段分隔符和输出字段分隔符都被赋值为制表符
- 逻辑操作符：\ ``&&、||、!``\ ，如\ ``$4 == "Asia" && $3 > 500``\ ，\ ``! (NR > 1 && NF > 3)``\ 

.. _awkctrl:

.. _awkfuncl:

0x0302 应用实例
+++++++++++++++++





